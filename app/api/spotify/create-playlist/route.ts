import { NextResponse } from "next/server";
import { cookies } from "next/headers";

const CLIENT_ID = process.env.SPOTIFY_CLIENT_ID;
const CLIENT_SECRET = process.env.SPOTIFY_CLIENT_SECRET;

export async function POST(request: Request) {
    const cookieStore = await cookies();
    let accessToken = cookieStore.get("spotify_access_token")?.value;
    const refreshToken = cookieStore.get("spotify_refresh_token")?.value;
    const expiresAt = cookieStore.get("spotify_expires_at")?.value;

    if (!accessToken && !refreshToken) {
        return NextResponse.json({ error: "Not connected" }, { status: 401 });
    }

    // 1. Check if expired and refresh if necessary
    if (!accessToken || (expiresAt && Date.now() > Number(expiresAt))) {
        if (!refreshToken) {
            return NextResponse.json({ error: "Session expired" }, { status: 401 });
        }

        try {
            const refreshParams = new URLSearchParams({
                grant_type: "refresh_token",
                refresh_token: refreshToken,
            });

            const refreshRes = await fetch("https://accounts.spotify.com/api/token", {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    Authorization:
                        "Basic " + Buffer.from(CLIENT_ID + ":" + CLIENT_SECRET).toString("base64"),
                },
                body: refreshParams,
            });

            if (!refreshRes.ok) {
                throw new Error("Failed to refresh token");
            }

            const refreshData = await refreshRes.json();
            accessToken = refreshData.access_token;

            // We should ideally update the cookie here for future requests, 
            // but for this specific "minimal logic" request, we just use the new token for this operation.
            // If we wanted to persist it, we'd need to set the Set-Cookie header on the response.
        } catch (e) {
            console.error("Token refresh failed", e);
            return NextResponse.json({ error: "Authentication failed" }, { status: 401 });
        }
    }

    try {
        const body = await request.json();
        const { name, description, isPublic, trackUrls } = body;

        if (!name) {
            return NextResponse.json({ error: "Playlist name is required" }, { status: 400 });
        }

        // 2. Get User Profile
        const userRes = await fetch("https://api.spotify.com/v1/me", {
            headers: { Authorization: `Bearer ${accessToken}` },
        });

        if (!userRes.ok) {
            return NextResponse.json({ error: "Failed to fetch user profile" }, { status: userRes.status });
        }

        const userData = await userRes.json();
        const userId = userData.id;

        // 3. Create Playlist
        const createRes = await fetch(`https://api.spotify.com/v1/users/${userId}/playlists`, {
            method: "POST",
            headers: {
                Authorization: `Bearer ${accessToken}`,
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                name: name,
                description: description || "Generated by Setifest",
                public: isPublic ?? false
            })
        });

        if (!createRes.ok) throw new Error("Failed to create playlist");

        const playlistData = await createRes.json();
        const playlistId = playlistData.id;
        const playlistUrl = playlistData.external_urls.spotify;

        // 4. Parse & Add Tracks
        if (trackUrls && Array.isArray(trackUrls) && trackUrls.length > 0) {
            const uris = trackUrls.map((url: string) => {
                // Check for spotify:track:ID
                if (url.startsWith("spotify:track:")) return url;

                // Check for https://open.spotify.com/track/ID format
                const match = url.match(/track\/([a-zA-Z0-9]+)/);
                if (match && match[1]) {
                    return `spotify:track:${match[1]}`;
                }
                return null;
            }).filter(Boolean); // Remove nulls

            if (uris.length > 0) {
                // Spotify API allows max 100 tracks per request
                // Batch in chunks of 100
                for (let i = 0; i < uris.length; i += 100) {
                    const batch = uris.slice(i, i + 100);
                    await fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, {
                        method: "POST",
                        headers: {
                            Authorization: `Bearer ${accessToken}`,
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({ uris: batch })
                    });
                }
            }
        }

        // 5. Return success
        return NextResponse.json({ playlistUrl });

    } catch (error) {
        console.error("Playlist creation error", error);
        return NextResponse.json({ error: "Internal Server Error" }, { status: 500 });
    }
}
